package ru.profit.teamcenter.import_tp.app.model.mapping_config.fox;

import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;

/**
 * Метаданные для маппинга строкового содержания ТП
 * каждая строка состоит из подстрок. разделитель для подстрок = "\"
 *
 * Существует ограничение - если указана вспомогательная строка для какой либо базовой строки,
 * то базовая строка должна переводиться в единственный тип объекта технологии. Не множественный.
 * Например: если строке A соответствует 2 типа - операция и инструкция, не должно быть вспомогательной строки
 * для которой в качестве основной указана A
 */
public interface MappingFromFoxToTpConfig {

    /**
     * Номер подстроки содержащей строку указывающую тип данных
     * @return
     */
    default Integer getNumberSubStringForSign(){
        return 0;
    }

    /**
     * Список типов объектов в ТП соответствующих определенному типу данных
     * В одной строке может быть информация для нескольких объектов (операция и ИОТ)
     * @param sign значение подстроки содержащий информацию о типе всей строки
     * @throws NoSuchElementException если нет связанных с указанным типом строки типов объеков в ТП.
     * Такое просходит когда строка является вспомагательной для других строк
     * @throws IllegalArgumentException тип строки не является допустимым в рамках маппинга
     * @return
     *
     */
    List<String> defineType(String sign) throws NoSuchElementException, IllegalArgumentException;

    /**
     * Список возможных типов строк
     * @return
     */
    List<String> getValidSigns();

    /**
     * Список маппинга номеров подстрок содержащих значения атрибутов и названий атрибутов
     * В одной строке может быть информация для нескольких объектов => несколько маппингов
     * Порядок мапингов названий атрибутов должен совпадать с порядком типов объектов (defineType(sign))
     *
     * Но возможно получение маппинга значений номеров подстрок и названий атрибутов когда строке не ставится
     * в соответствие определенный тип объекта, т.е. если строка является вспомогательной.
     *
     * @param sign значение подстроки содержащий информацию о типе всей строки
     */
    List<Map<Integer,String>> getNumberSubstringAndAttribute(String sign);

    //--------------------------------------------------------------------------------------

    /**
     * Для каких строк строка с указанным типом является вспомагательной.
     *
     * Некоторые сроки не маппятся на типы модели технологии, а являются вспомогательными для других строк.
     * Результирующий объект в моделе является объектом типа соответствующим основной строке.
     * Результируюший объект содержит атрибуты определенные с помощью миксера
     * @param signOfSupportingLine значение подстроки содержащий информацию о типе всей вспомагательной строки
     * @return
     */
    List<String> getSignsOfBasedLines(String signOfSupportingLine);

    /**
     * В каком направлении искать строку, для которой указанная является вспомагательной
     * @param signOfSupportingLine значение подстроки содержащий информацию о типе всей вспомогательной строки
     * @return true вверх по списку строк, false вниз
     */
    Boolean goUpForDefineBaseString(String signOfSupportingLine);


    /**
     * Соотвветствие типов строк, номерв подстрок в них и используемых разделителей значений в этих посдтроках
     * @return например для Операции, где для разделения номеров ИОТ используется запятая A -> (6 -> ",")
     */
    Map<String, Map<Integer, String>> getSeparatorsForSubstringsInLines();

    /**
     * Разделитель значений атрибута для указанной подстроки в указанной строке
     * @param signOfLine
     * @param numberOfSubstring
     * @return
     * @throws NoSuchElementException если не определено разделителя значений для подстроки
     */
    String getSeparatorForValuesInSubstringSpecificLine(String signOfLine, Integer numberOfSubstring) throws NoSuchElementException;
}
